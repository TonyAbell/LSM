
leaf page
--------

1 byte page type
1 byte page flags

4 bytes, int, previous page num
    skips over any overflow pages from this leaf

2 bytes, int, number of pairs

lastint32 reserved for boundary page ptr

for each pair:
    key
    value

each key:
	1 byte flags, overflow or not, plus tombstone or not

	if not overflow
	    varint length
	    N bytes key itself

	if overflow
	    varint length
	    4 bytes page number

if not tombstone, value is:
    1 byte flags, overflow or not

	if not overflow
	    varint length
	    N bytes val itself

	if overflow
	    varint length
	    4 bytes page number

overflow page
--------

first page:
    1: pagetype (overflow)
    1: flags 0 or "last page is a boundary" or "this page is a boundary"
    (the data), pageSize - 6
    4: number of pages in this block (skip)

interior pages: 
    just data

final page of a block: 
    just data, minus 4 bytes, for the nextpage field at the end

first page can hold pageSize - 6 bytes.  others can hold pageSize.
except the last one, which can hold pageSize - 4.

overflow only if the key/value is larger than a page.  in other
words, if bumping to the next page would make it fit, then no
overflow.

parent node page
--------

1 byte page type
1 byte page flags

2 bytes count keys (n)

lastint32 reserved for boundary page ptr

root node only:  
    second-to-lastint32 reserved for firstleaf.  
    lastint32 is lastleaf.

pointers.  (n+1) of them.  varints.

keys.  (n) of them.

each key is:

	1 byte flags, overflow or not

	if not overflow
	varint length
	N bytes key itself

	if overflow
	varint length
	4 bytes page number

