
look at reducing memory allocations in writeLeaves

failWith

write a test that verifies that BTreeSegment.Create
never seeks if it has no boundary.  this preserves
the ability to write a btree into almost any kind of
stream.  common use case remains writing with an
involved page manager.

--------

test multicursor with the same cursor twice?

test multicursor with two identical subs?

--------

fsharp stuff:

encapuslate mutable local-function-variables in a class?

way too many mutables in the fs code

way too many if-then places in the fs code

way too many for/while loops in the fs code

no exception throwing?  everything needs to return status.
but almost everything in .NET throws.  need F#-specific
implementation of things like SortedDictionary?

--------

checksums for data integrity

still concerned about how much we are copying byte[] for keys

prefix key compression?

what are the embedded pointers in the runs in SQLite4 LSM?

tombstones shouldn't need a length field as well.
but the absence would mess up the space_needed calcs.
and if the length is always zero, it's just a byte.

needed a way to ask a cursor if a
value is a tombstone without retrieving it.  it could be
huge, and all we wanna know is if it exists.  why doesn't
sqlite4's LSM have ICursor.ValueLength()?

fix the realloc of leafKeys in the cs code as well?  or is
the cs code just becoming part of the fs version's test suite?

--------

once "on disk", a segment is immutable.  reads only.
only the first (in-memory) segment needs to support writes.

maybe the whole thing should implement IDictionary<byte[],byte[]> ?

--------

is there any chance we should be using things like Stream.ReadAsync?
async-ness would propagate all the way up...  or should the decision
to use async/threads be up to the caller, like the threads test I've
got?

--------

can we write an overflow without knowing its length in
advance?  that would be handy.  maybe we could chain a
zlib stream and compress as it goes in.  but how do we
set the skip field?  we pretty much can't.  I suppose we
could just write the whole thing and then go back and
write the skip field.

we can't do calculations on whether a value will fit if
we don't know its length.  such a value automatically
becomes an overflow.  after we write the overflow, then
we know its length.


