
write a test that has multiple things writing pages 
at the same time

should any of the extension methods for IWrite.Insert
move into the core code?

for a given segment, we need a way to keep track of all
the blocks/pages that were used by the segment.  either
BTreeSegment.Create needs to return all this info, or
the page manager needs to keep track along the way.

IWrite needs to have an open cursor which can always see changes
that were just made.  so the idea of using a plain dictionary
and then sorting the keys when the cursor is opened?  that
won't work.  IWrite is an ICursor with two more methods.

IWrite basically represents an open write transaction.
commit: flush it to a btree and update the segment list.
rollback: just throw it away.

An open read transaction is just an ICursor (probably a
multicursor) where nothing is changing.  it points to a
segment list.  a readonly tx never needs to know about the
in memory tree.

a segment list is just a list of filenames for segments.
or, in a single-file design, it's a list of starting page 
numbers for segments.

there is always one segment list which is the current one.
the last step of committing a new write tx is to add a new
segment list and update the "current segment list" pointer
to refer to it.

a readonly tx simply opens an ICursor on the current segment
list.

A segment list which is no longer current can be discarded
once it has no open ICursors.

A segment can be discarded if it is no longer a member of
any segment lists.

In a single file design, a segment list should probably be
limited to a single page?

Merging segments should not interfere with anything else
until it needs to fiddle with the segments list.  For example,
if we are merging A and B to make C.  We have ICursors on A
and B, and we are creating C (which is not a write tx).  Once
we are done, we should add a new segment list which is a copy
of the current one, but with A+B replaced with C.  Then
atomically update the current seglist.  So it kind of is a
a write tx?

is there some natural limit to the number of segment lists
which can exist?

segment lists should immutably share nodes.  it's just a linked
list, right?

merging segments, in principle, does not change the database.
all queries will return what they did before, except faster.

flushing a memory segment actually does change the db.  it
inserts a new head into the segment list.

maybe we only need one segment list?  a reader simply slurps
the whole page into ram and doesn't need it again.  in other
words, the segment list for an active reader exists only in
RAM.

hold a write lock as soon as the write tx object is created,
so that when we are ready to write the segment list page,
there won't have been any changes in the meantime.

merging segments, no need for any lock (except read locks for
the cursors) until we are ready to write the segment list page,
at which time we can just wait for any writer to be done, then
read the segment list, and write it back out.

--------

encapuslate mutable local-function-variables in a class?

fix the realloc of leafKeys in the cs code as well

memorysegment opencursor is slow, profile says so.  because
of the sort of the dictionary keys.

test multicursor with the same cursor twice?

test multicursor with two identical subs?

way too many mutables in the fs code

way too many if-then places in the fs code

way too many for/while loops in the fs code

test multicursor with more than 2 subs

no exception throwing?  everything needs to return status.
but almost everything in .NET throws.  need F#-specific
implementation of things like SortedDictionary?

checksums for data integrity

still concerned about how much we are copying byte[] for keys

prefix key compression?

what are the embedded pointers in the runs in SQLite4 LSM?

zlib compression?  maybe just for overflow pages?

tombstones shouldn't need a length field as well.
but the absence would mess up the space_needed calcs.
and if the length is always zero, it's just a byte.

needed a way to ask a cursor if a
value is a tombstone without retrieving it.  it could be
huge, and all we wanna know is if it exists.  why doesn't
sqlite4's LSM have ICursor.vlen()?

--------

conceptually, we COULD write every new segment to disk after commit

once "on disk", a segment is immutable.  reads only.
only the first (in-memory) segment needs to support writes.

maybe the whole thing should implement IDictionary<byte[],byte[]> ?

