
redo storage of overflows

implement IPageManager
    GetNewRange
    GetConsecutivePageGroup

implement the calls to the page manager

get rid of searchForwardForLeaf

consider moving rootpage first/leaf leaf to the end
of the page

write tests which deal with different page ranges

and need to remember that an overflow might be longer than a
block.  so we can't actually promise that they're consecutive.
unless we have different rules for overflows then for leaves
and parents.  which would be possible if we stored overflows
separately.

we don't really need blocks unless we want to allow multiple
btree writers at the same time.  we could just always be
appending to the end of the file.

but then how would we reclaim blocks in the middle of the
file.  we can't write a segment there unless we know it's
going to fit, which we don't.

overflows could be written separately from their segments?
but still consecutive pages for a given overflow.  

so we could
pass Create() a first page and then a last available page.
on the last available, set a flag on it, and put a next page
field at the end.  unless it's the root page.  which we know.

readers would have to respect the flag when searching forward.

IWrite needs to have an open cursor which can always see changes
that were just made.  so the idea of using a plain dictionary
and then sorting the keys when the cursor is opened?  that
won't work.  IWrite is an ICursor with two more methods.

IWrite basically represents an open write transaction.
commit: flush it to a btree and update the segment list.
rollback: just throw it away.

An open read transaction is just an ICursor (probably a
multicursor) where nothing is changing.  it points to a
segment list.  a readonly tx never needs to know about the
in memory tree.

a segment list is just a list of filenames for segments.
or, in a single-file design, it's a list of starting page 
numbers for segments.

there is always one segment list which is the current one.
the last step of committing a new write tx is to add a new
segment list and update the "current segment list" pointer
to refer to it.

a readonly tx simply opens an ICursor on the current segment
list.

A segment list which is no longer current can be discarded
once it has no open ICursors.

A segment can be discarded if it is no longer a member of
any segment lists.

In a single file design, a segment list should probably be
limited to a single page?

Merging segments should not interfere with anything else
until it needs to fiddle with the segments list.  For example,
if we are merging A and B to make C.  We have ICursors on A
and B, and we are creating C (which is not a write tx).  Once
we are done, we should add a new segment list which is a copy
of the current one, but with A+B replaced with C.  Then
atomically update the current seglist.  So it kind of is a
a write tx?

is there some natural limit to the number of segment lists
which can exist?

segment lists should immutably share nodes.  it's just a linked
list, right?

merging segments, in principle, does not change the database.
all queries will return what they did before, except faster.

flushing a memory segment actually does change the db.  it
inserts a new head into the segment list.

maybe we only need one segment list?  a reader simply slurps
the whole page into ram and doesn't need it again.  in other
words, the segment list for an active reader exists only in
RAM.

hold a write lock as soon as the write tx object is created,
so that when we are ready to write the segment list page,
there won't have been any changes in the meantime.

merging segments, no need for any lock (except read locks for
the cursors) until we are ready to write the segment list page,
at which time we can just wait for any writer to be done, then
read the segment list, and write it back out.

--------

encapuslate mutable local-function-variables in a class?

fix the realloc of leafKeys in the cs code as well

memorysegment opencursor is slow, profile says so

test multicursor with the same cursor twice?

test multicursor with two identical subs?

way too many mutables in the fs code

way too many if-then places in the fs code

way too many for/while loops in the fs code

should memorysegment for fs be written with an immutable collection?

test multicursor with more than 2 subs

test several iterations of creating a btree from two others.

check for problems with assumptions about what Stream.Length
returns.  Is it the whole stream length?  Or what's left?  And
does the code assume one way or the other?

feels like mostly the uint vs int stuff is just causing trouble.

--------

transactions

--------

no exception throwing?  everything needs to return status.
but almost everything in .NET throws.  need F#-specific
implementation of things like SortedDictionary?

checksums for data integrity

still concerned about how much we are copying byte[] for keys

overflow page number could be a varint?

how to make this work within a larger file?
this is why sqlite4 lsm has "blocks" of pages.

btree_segment.create() needs to take a page size
and a base pagenumber.

prefix key compression?

zlib compression?  maybe just for overflow pages?

tombstones shouldn't need a length field as well.
but the absence would mess up the space_needed calcs.
and if the length is always zero, it's just a byte.

needed a way to ask a cursor if a
value is a tombstone without retrieving it.  it could be
huge, and all we wanna know is if it exists.  why doesn't
sqlite4's LSM have ICursor.vlen()?

--------

conceptually, we COULD write every new segment to disk after commit

once "on disk", a segment is immutable.  reads only.
only the first (in-memory) segment needs to support writes.

maybe the whole thing should implement IDictionary<byte[],byte[]> ?

