
need tests that read from an overflow stream asking
for smaller amounts of data

could maybe remove support for a boundary <= 0

see if a block size of 1 page actually works.  probably
not.  and probably should be disallowed anyway.

--------

page manager needs to keep track of all the pages and
remember what's free.  and it needs to remember all
the segments.  all the blocks.

do we need a segment info thing written to the disk?
like for each segment, a list of all its blocks?

tx stuff:

even for IWrite, open cursor, an ICursor always gives
a view of data that cannot change while you are reading it.

IWrite basically represents an open write transaction.
commit: flush it to a btree and update the segment list.
rollback: just throw it away.

An open read transaction is just an ICursor (probably a
multicursor) where nothing is changing.  it points to a
segment list.  a readonly tx never needs to know about the
in memory tree.

a segment list is just a list of filenames for segments.
or, in a single-file design, it's a list of starting page 
numbers for segments.

there is always one segment list which is the current one.
the last step of committing a new write tx is to add a new
segment list and update the "current segment list" pointer
to refer to it.

a readonly tx simply opens an ICursor on the current segment
list.

A segment list which is no longer current can be discarded
once it has no open ICursors.

A segment can be discarded if it is no longer a member of
any segment lists.

In a single file design, a segment list should probably be
limited to a single page?

Merging segments should not interfere with anything else
until it needs to fiddle with the segments list.  For example,
if we are merging A and B to make C.  We have ICursors on A
and B, and we are creating C (which is not a write tx).  Once
we are done, we should add a new segment list which is a copy
of the current one, but with A+B replaced with C.  Then
atomically update the current seglist.  So it kind of is a
a write tx?

is there some natural limit to the number of segment lists
which can exist?

segment lists should immutably share nodes.  it's just a linked
list, right?

merging segments, in principle, does not change the database.
all queries will return what they did before, except faster.

flushing a memory segment actually does change the db.  it
inserts a new head into the segment list.

maybe we only need one segment list?  a reader simply slurps
the whole page into ram and doesn't need it again.  in other
words, the segment list for an active reader exists only in
RAM.

hold a write lock as soon as the write tx object is created,
so that when we are ready to write the segment list page,
there won't have been any changes in the meantime.

merging segments, no need for any lock (except read locks for
the cursors) until we are ready to write the segment list page,
at which time we can just wait for any writer to be done, then
read the segment list, and write it back out.

--------

test multicursor with the same cursor twice?

test multicursor with two identical subs?

--------

fsharp stuff:

encapuslate mutable local-function-variables in a class?

way too many mutables in the fs code

way too many if-then places in the fs code

way too many for/while loops in the fs code

test multicursor with more than 2 subs

no exception throwing?  everything needs to return status.
but almost everything in .NET throws.  need F#-specific
implementation of things like SortedDictionary?

--------

checksums for data integrity

still concerned about how much we are copying byte[] for keys

prefix key compression?

what are the embedded pointers in the runs in SQLite4 LSM?

tombstones shouldn't need a length field as well.
but the absence would mess up the space_needed calcs.
and if the length is always zero, it's just a byte.

needed a way to ask a cursor if a
value is a tombstone without retrieving it.  it could be
huge, and all we wanna know is if it exists.  why doesn't
sqlite4's LSM have ICursor.vlen()?

fix the realloc of leafKeys in the cs code as well?  or is
the cs code just becoming part of the fs version's test suite?

--------

conceptually, we COULD write every new segment to disk after commit

once "on disk", a segment is immutable.  reads only.
only the first (in-memory) segment needs to support writes.

maybe the whole thing should implement IDictionary<byte[],byte[]> ?

--------

we can't do calculations on whether a value will fit if
we don't know its length.

or maybe we just need to handle valueStreams which cannot
do Length as a separate code path?

can we write an overflow without knowing its length in
advance?  that would be handy.  maybe we could chain a
zlib stream and compress as it goes in.  but how do we
set the skip field?  we pretty much can't.  I suppose we
could just write the whole thing and then go back and
write the skip field.

--------

first page:
    1: pagetype (overflow)
    1: flags 0 or "last page is a boundary" or "this page is a boundary"
    (the data), pageSize - 6
    4: number of pages in this block (skip)

interior pages: 
    just data

final page of a block: 
    just data, minus 4 bytes, for the nextpage field at the end

first page can hold pageSize - 6 bytes.  others can hold pageSize.
except the last one, which can hold pageSize - 4.

and maybe OverflowReadStream should just read directly
into the given ba instead of reading the whole page and
copying.

